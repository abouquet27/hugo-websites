<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en-us lang=en-us><head><script defer language=javascript type=text/javascript src=/js/bundle.min.14549c76bbc96f0af1574b0259efd70e52908cd36fb4d14ed3d290a1b6479eae.js></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon href=https://github.com/abouquet27.png><title itemprop=name>Adrien's Dashbook - Building a robust test suite of type confusion vulnerabilities</title><meta property="og:title" content="Adrien's Dashbook - Building a robust test suite of type confusion vulnerabilities"><meta name=twitter:title content="Adrien's Dashbook - Building a robust test suite of type confusion vulnerabilities"><meta itemprop=name content="Adrien's Dashbook - Building a robust test suite of type confusion vulnerabilities"><meta name=application-name content="Adrien's Dashbook - Building a robust test suite of type confusion vulnerabilities"><meta property="og:site_name" content="Adrien's Dashbook"><meta name=description content="Master semester project @ HexHive Lab, EPFL"><meta itemprop=description content="Master semester project @ HexHive Lab, EPFL"><meta property="og:description" content="Master semester project @ HexHive Lab, EPFL"><meta name=twitter:description content="Master semester project @ HexHive Lab, EPFL"><base href=/writings/type-confusions/type-confusions/><link rel=canonical href=/writings/type-confusions/type-confusions/ itemprop=url><meta name=url content="/writings/type-confusions/type-confusions/"><meta name=twitter:url content="/writings/type-confusions/type-confusions/"><meta property="og:url" content="/writings/type-confusions/type-confusions/"><meta property="og:updated_time" content="2024-06-07T00:00:00Z"><link rel=sitemap type=application/xml title=Sitemap href=/sitemap.xml><meta name=robots content="index,follow"><meta name=googlebot content="index,follow"><meta property="fb:admins" content><meta name=apple-mobile-web-app-title content="Adrien's Dashbook"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="black"><meta name=generator content="Hugo 0.111.3"><link type=text/css rel=stylesheet href=/css/bundle.min.32e072375594147fab0331542e2b1a94787a0462b7949f9fa2a3eb72bc12113a.css><style>body{--sidebar-bg-color:#1b1838;--sidebar-img-border-color:#FFF;--sidebar-p-color:#C0C0C0;--sidebar-h1-color:#FFF;--sidebar-a-color:#FFF;--sidebar-socials-color:#FFF;--text-color:#222;--bkg-color:#FAF9F6;--post-title-color:#303030;--list-color:#5A5A5A;--link-color:#268BD2;--date-color:#515151;--table-border-color:#E5E5E5;--table-stripe-color:#F9F9F9;--code-color:#000;--code-background-color:#FAF9F6;--code-block-color:#FFF;--code-block-background-color:#1b1838;--moon-sun-color:#FFF;--moon-sun-background-color:#180E6D}body.dark-theme{--text-color:#EEE;--bkg-color:#14102a;--post-title-color:#DBE2E9;--list-color:#9D9D9D;--link-color:#05fe68;--date-color:#AAAAAA;--table-border-color:#C0C0C0;--table-stripe-color:#202020;--code-color:#FFF;--code-background-color:#14102a;--code-block-color:#FFF;--code-block-background-color:#14102a}body{background-color:var(--bkg-color)}</style></head><body class=dark-theme><div class=wrapper><aside class=sidebar><div class="container sidebar-sticky"><div class=light-dark align=right><button class=btn-light-dark title="Toggle light/dark mode"><svg class="moon" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 16 16"><path fill="currentcolor" d="M6 .278a.768.768.0 01.08.858 7.208 7.208.0 00-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527.0 1.04-.055 1.533-.16a.787.787.0 01.81.316.733.733.0 01-.031.893A8.349 8.349.0 018.344 16C3.734 16 0 12.286.0 7.71.0 4.266 2.114 1.312 5.124.06A.752.752.0 016 .278z"/></svg><svg class="sun" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 16 16"><path fill="currentcolor" d="M8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 0zm0 13a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 13zm8-5a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2a.5.5.0 01.5.5zM3 8a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2A.5.5.0 013 8zm10.657-5.657a.5.5.0 010 .707l-1.414 1.415a.5.5.0 11-.707-.708l1.414-1.414a.5.5.0 01.707.0zm-9.193 9.193a.5.5.0 010 .707L3.05 13.657a.5.5.0 01-.707-.707l1.414-1.414a.5.5.0 01.707.0zm9.193 2.121a.5.5.0 01-.707.0l-1.414-1.414a.5.5.0 01.707-.707l1.414 1.414a.5.5.0 010 .707zM4.464 4.465a.5.5.0 01-.707.0L2.343 3.05a.5.5.0 11.707-.707l1.414 1.414a.5.5.0 010 .708z"/></svg></button></div><div class=sidebar-about><h1 class=brand><a href=/><img src=/images/adrienacco2.jpg alt="brand image"></a>
<a href=/><h1>Adrien's Dashbook</h1></a></h1><p class=lead>My personnal blog where I share interesting stuff</p></div><nav><ul class=sidebar-nav><li class=heading><a href=/about/>About</a></li><li class=heading><a href=/writings/>Writings</a></li><li class=heading><a href=/posts/>Posts</a></li><li class=sub-heading></li><li class=bullet><a href=/posts/new-website/>New Website</a></li></ul></nav><a target=_blank class=social title=GitHub href=https://github.com/abouquet27><svg xmlns="http://www.w3.org/2000/svg" width="1.2em" height="1.2em" viewBox="-2 -2 24 24"><path fill="currentcolor" d="M18.88 1.099C18.147.366 17.265.0 16.233.0H3.746C2.714.0 1.832.366 1.099 1.099.366 1.832.0 2.714.0 3.746v12.487c0 1.032.366 1.914 1.099 2.647.733.733 1.615 1.099 2.647 1.099H6.66c.19.0.333-.007.429-.02a.504.504.0 00.286-.169c.095-.1.143-.245.143-.435l-.007-.885c-.004-.564-.006-1.01-.006-1.34l-.3.052c-.19.035-.43.05-.721.046a5.555 5.555.0 01-.904-.091 2.026 2.026.0 01-.872-.39 1.651 1.651.0 01-.572-.8l-.13-.3a3.25 3.25.0 00-.41-.663c-.186-.243-.375-.407-.566-.494l-.09-.065a.956.956.0 01-.17-.156.723.723.0 01-.117-.182c-.026-.061-.004-.111.065-.15.07-.04.195-.059.378-.059l.26.04c.173.034.388.138.643.311a2.1 2.1.0 01.631.677c.2.355.44.626.722.813.282.186.566.28.852.28.286.0.533-.022.742-.065a2.59 2.59.0 00.585-.196c.078-.58.29-1.028.637-1.34a8.907 8.907.0 01-1.333-.234 5.314 5.314.0 01-1.223-.507 3.5 3.5.0 01-1.047-.872c-.277-.347-.505-.802-.683-1.365-.177-.564-.266-1.215-.266-1.952.0-1.049.342-1.942 1.027-2.68-.32-.788-.29-1.673.091-2.652.252-.079.625-.02 1.119.175.494.195.856.362 1.086.5.23.14.414.257.553.352a9.233 9.233.0 012.497-.338c.859.0 1.691.113 2.498.338l.494-.312a6.997 6.997.0 011.197-.572c.46-.174.81-.221 1.054-.143.39.98.424 1.864.103 2.653.685.737 1.028 1.63 1.028 2.68.0.737-.089 1.39-.267 1.957-.177.568-.407 1.023-.689 1.366a3.65 3.65.0 01-1.053.865c-.42.234-.828.403-1.223.507a8.9 8.9.0 01-1.333.235c.45.39.676 1.005.676 1.846v3.11c0 .147.021.266.065.357a.36.36.0 00.208.189c.096.034.18.056.254.064.074.01.18.013.318.013h2.914c1.032.0 1.914-.366 2.647-1.099.732-.732 1.099-1.615 1.099-2.647V3.746c0-1.032-.367-1.914-1.1-2.647z"/></svg></a><a target=_blank class=social title=Gitlab href=https://gitlab.com/abouquet27><svg xmlns="http://www.w3.org/2000/svg" width="1.2em" height="1.2em" viewBox="-2 -2.5 24 24"><path fill="currentcolor" d="M10.006 18.443 6.326 7.118h7.36l-3.68 11.325zm0 0L1.168 7.118h5.158l3.68 11.325zM1.168 7.118l8.838 11.325-9.68-7.032a.762.762.0 01-.276-.852l1.118-3.441zm0 0L3.385.296a.38.38.0 01.724.0l2.217 6.822H1.168zm8.838 11.325 3.68-11.325h5.157l-8.837 11.325zm8.837-11.325 1.119 3.441a.762.762.0 01-.277.852l-9.68 7.032 8.838-11.325zm0 0h-5.157L15.902.296a.38.38.0 01.725.0l2.216 6.822z"/></svg></a><a target=_blank class=social title=LinkedIn href=https://www.linkedin.com/in/adrien-bouquet-3a1a742a4/><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1.2em" viewBox="0 0 448 512"><path fill="currentcolor" d="M416 32H31.9C14.3 32 0 46.5.0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6.0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3.0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2.0 38.5 17.3 38.5 38.5.0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6.0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2.0 79.7 44.3 79.7 101.9V416z"/></svg></a><a target=_blank class=social title=TryHackMe href=https://tryhackme.com/p/adrbqt><svg xmlns="http://www.w3.org/2000/svg" width="1.2em" height="1.2em" viewBox="0 0 24 24"><path fill="#fff" d="M10.705.0C7.54.0 4.902 2.285 4.349 5.291a4.525 4.525.0 00-4.107 4.5 4.525 4.525.0 004.52 4.52h6.761a.625.625.0 100-1.25H4.761a3.273 3.273.0 01-3.27-3.27A3.273 3.273.0 016.59 7.08a.625.625.0 00.7-1.035 4.488 4.488.0 00-1.68-.69 5.223 5.223.0 015.096-4.104 5.221 5.221.0 015.174 4.57 4.489 4.489.0 00-.488.305.625.625.0 10.731 1.013 3.245 3.245.0 011.912-.616 3.278 3.278.0 013.203 2.61.625.625.0 001.225-.251 4.533 4.533.0 00-4.428-3.61 4.54 4.54.0 00-.958.105C16.556 2.328 13.9.0 10.705.0zm5.192 10.64a.925.925.0 00-.462.108.913.913.0 00-.313.29 1.27 1.27.0 00-.175.427 2.39 2.39.0 00-.054.514c0 .181.018.353.054.517s.095.307.175.43a.899.899.0 00.313.297c.127.073.281.11.462.11.18.0.334-.037.46-.11a.897.897.0 00.309-.296c.08-.124.137-.267.173-.431.036-.164.054-.336.054-.517.0-.18-.018-.352-.054-.514a1.271 1.271.0 00-.173-.426.901.901.0 00-.309-.291.917.917.0 00-.46-.108zm6.486.0a.925.925.0 00-.462.108.913.913.0 00-.313.29 1.27 1.27.0 00-.175.427 2.39 2.39.0 00-.053.514c0 .181.017.353.053.517s.095.307.175.43a.899.899.0 00.313.297c.127.073.281.11.462.11.18.0.334-.037.46-.11a.897.897.0 00.31-.296c.078-.124.136-.267.172-.431s.054-.336.054-.517c0-.18-.018-.352-.054-.514a1.271 1.271.0 00-.173-.426.901.901.0 00-.308-.291.916.916.0 00-.461-.108zm-8.537.068-.84.618.313.43.476-.368v1.877h.603v-2.557zm6.486.0-.841.618.314.43.477-.368v1.877h.603v-2.557zm-4.435.445c.08.0.143.028.193.084.05.057.087.127.114.21.026.083.044.173.054.269a2.541 2.541.0 010 .533c-.01.097-.028.187-.054.27a.584.584.0 01-.114.21.243.243.0 01-.193.085.248.248.0 01-.195-.086.584.584.0 01-.118-.209 1.245 1.245.0 01-.056-.27 2.645 2.645.0 010-.533c.01-.096.029-.186.056-.27a.583.583.0 01.118-.209.25.25.0 01.195-.084zm6.486.0c.08.0.144.028.193.084.05.057.087.127.114.21s.044.173.054.269a2.541 2.541.0 010 .533c-.01.097-.027.187-.054.27a.584.584.0 01-.114.21.243.243.0 01-.193.085.249.249.0 01-.195-.086.581.581.0 01-.117-.209 1.245 1.245.0 01-.056-.27 2.642 2.642.0 010-.533c.01-.096.028-.186.056-.27a.58.58.0 01.117-.209.25.25.0 01.195-.084zm-2.191 3.51a.93.93.0 00-.463.109.908.908.0 00-.312.291c-.08.122-.139.263-.175.426a2.383 2.383.0 00-.054.514c0 .18.018.353.054.516.036.164.094.308.175.432a.91.91.0 00.312.296.92.92.0 00.463.11c.18.0.333-.037.46-.11a.892.892.0 00.308-.296 1.32 1.32.0 00.174-.432c.036-.163.054-.335.054-.516.0-.18-.018-.352-.054-.514a1.274 1.274.0 00-.174-.426.89.89.0 00-.309-.291.918.918.0 00-.46-.108zm-6.402.07-.841.617.314.43.476-.369v1.878h.604v-2.557zm2.125.0-.841.617.314.43.477-.369v1.878h.603v-2.557zm2.116.0-.84.617.313.43.477-.369v1.878h.603v-2.557zm2.16.443c.08.0.144.028.194.085a.605.605.0 01.114.21c.026.083.044.172.053.269a2.639 2.639.0 010 .532 1.28 1.28.0 01-.053.27.585.585.0 01-.114.21.244.244.0 01-.193.085.25.25.0 01-.196-.085.589.589.0 01-.117-.21 1.245 1.245.0 01-.056-.27 2.597 2.597.0 010-.532c.01-.097.028-.186.056-.27a.589.589.0 01.117-.209.249.249.0 01.196-.085zm-6.729 3.073a.676.676.0 00-.335.078.661.661.0 00-.227.211.91.91.0 00-.127.31c-.027.118-.04.242-.04.373s.013.256.04.375a.93.93.0 00.127.313.65.65.0 00.227.215c.092.053.204.08.335.08a.655.655.0 00.334-.08.65.65.0 00.225-.215c.057-.09.1-.194.125-.313a1.75 1.75.0 00.04-.375c0-.13-.014-.255-.04-.373a.931.931.0 00-.125-.31.658.658.0 00-.225-.21.667.667.0 00-.334-.08zm3.086.0a.675.675.0 00-.336.078.661.661.0 00-.226.211.907.907.0 00-.127.31 1.69 1.69.0 00-.04.373c0 .131.013.256.04.375a.928.928.0 00.127.313c.058.09.134.162.226.215.093.053.205.08.336.08a.655.655.0 00.334-.08.65.65.0 00.224-.215c.058-.09.1-.194.126-.313a1.752 1.752.0 000-.748.94.94.0 00-.126-.31.657.657.0 00-.224-.21.667.667.0 00-.334-.08zm5.108.0a.675.675.0 00-.336.078.661.661.0 00-.226.211.91.91.0 00-.127.31c-.027.118-.04.242-.04.373s.013.256.04.375a.931.931.0 00.127.313c.058.09.134.162.226.215.093.053.205.08.336.08.13.0.243-.027.334-.08a.65.65.0 00.224-.215c.058-.09.1-.194.126-.313a1.75 1.75.0 00.04-.375c0-.13-.014-.255-.04-.373a.943.943.0 00-.126-.31.657.657.0 00-.224-.21.668.668.0 00-.334-.08zm-6.658.05-.61.448.227.311.346-.266v1.362h.438v-1.856zm3.068.0-.61.448.227.311.346-.266v1.362h.438v-1.856zm5.108.0-.611.448.228.311.346-.266v1.362h.438v-1.856zm-9.712.322c.058.0.105.02.14.062a.421.421.0 01.083.151.96.96.0 01.04.196 1.932 1.932.0 010 .386.954.954.0 01-.04.197.421.421.0 01-.083.152.176.176.0 01-.14.061.18.18.0 01-.141-.06.427.427.0 01-.085-.153.887.887.0 01-.041-.197 1.96 1.96.0 010-.386.893.893.0 01.04-.196.42.42.0 01.086-.151.181.181.0 01.141-.062zm3.086.0c.058.0.104.02.14.062a.421.421.0 01.082.151.94.94.0 01.04.196 1.906 1.906.0 010 .386.93.93.0 01-.04.197.421.421.0 01-.082.152.176.176.0 01-.14.061.18.18.0 01-.141-.06.42.42.0 01-.086-.153.846.846.0 01-.04-.197 1.965 1.965.0 01-.011-.195c0-.057.004-.121.01-.191a.849.849.0 01.041-.196.42.42.0 01.086-.151.182.182.0 01.141-.062zm5.108.0c.058.0.104.02.14.062a.421.421.0 01.082.151.92.92.0 01.04.196 1.963 1.963.0 010 .386.943.943.0 01-.04.197.421.421.0 01-.082.152.177.177.0 01-.14.061.18.18.0 01-.142-.06.437.437.0 01-.085-.153.95.95.0 01-.04-.197 1.965 1.965.0 01-.011-.195c0-.057.004-.121.01-.191a.959.959.0 01.04-.196.47.47.0 01.086-.151.181.181.0 01.142-.062zm-1.684 1.814a.675.675.0 00-.336.079.66.66.0 00-.227.21.91.91.0 00-.127.31 1.731 1.731.0 000 .748.939.939.0 00.127.314c.059.09.134.162.227.215s.205.08.336.08a.66.66.0 00.334-.08.648.648.0 00.224-.215c.058-.09.1-.195.126-.314a1.737 1.737.0 00-.001-.747.928.928.0 00-.125-.31.65.65.0 00-.224-.211.668.668.0 00-.334-.079zm3.063.0a.676.676.0 00-.336.079.664.664.0 00-.227.21.906.906.0 00-.127.31 1.74 1.74.0 000 .748.936.936.0 00.127.314.66.66.0 00.227.215c.092.053.204.08.336.08a.654.654.0 00.334-.08.648.648.0 00.223-.215c.058-.09.1-.195.126-.314a1.74 1.74.0 000-.747.928.928.0 00-.126-.31.65.65.0 00-.223-.211.666.666.0 00-.334-.079zm-1.545.05-.611.448.228.312.346-.267v1.363h.438v-1.856zm-1.518.323c.057.0.104.02.14.061a.42.42.0 01.082.152.91.91.0 01.04.195 1.966 1.966.0 010 .387.951.951.0 01-.04.197.421.421.0 01-.082.152.177.177.0 01-.14.06.18.18.0 01-.142-.06.428.428.0 01-.085-.152.914.914.0 01-.04-.197 1.96 1.96.0 01-.011-.195c0-.058.003-.122.01-.192a.923.923.0 01.041-.195c.02-.06.048-.11.085-.152a.181.181.0 01.142-.061zm3.063.0c.057.0.104.02.14.061a.42.42.0 01.082.152.94.94.0 01.04.195 1.91 1.91.0 010 .387.93.93.0 01-.04.197.422.422.0 01-.083.152.175.175.0 01-.14.06.18.18.0 01-.141-.06.423.423.0 01-.085-.152.907.907.0 01-.04-.197 1.95 1.95.0 010-.387.915.915.0 01.04-.195c.02-.06.048-.11.085-.152a.182.182.0 01.142-.061zm-9.713.185a.465.465.0 00-.232.055.456.456.0 00-.157.146.627.627.0 00-.089.215 1.168 1.168.0 00-.027.259c0 .09.009.177.027.26a.648.648.0 00.089.216c.04.063.093.112.157.149a.459.459.0 00.232.056c.09.0.168-.02.231-.056a.45.45.0 00.156-.149.67.67.0 00.087-.217 1.218 1.218.0 000-.518.647.647.0 00-.087-.215.448.448.0 00-.156-.146.458.458.0 00-.23-.055zm1.052.035-.423.31.158.217.24-.185v.944h.303v-1.286zm-1.052.224c.04.0.073.014.097.042a.284.284.0 01.057.105.69.69.0 01.028.136c.004.049.007.092.007.133.0.04-.003.086-.007.135a.684.684.0 01-.028.136.285.285.0 01-.057.105.123.123.0 01-.097.043.125.125.0 01-.098-.043.298.298.0 01-.059-.105.612.612.0 01-.028-.136 1.39 1.39.0 010-.268.62.62.0 01.028-.136.297.297.0 01.06-.105.125.125.0 01.097-.042zm3.775 1.394a.463.463.0 00-.232.054.452.452.0 00-.157.146.621.621.0 00-.088.214 1.19 1.19.0 000 .519.641.641.0 00.088.217.46.46.0 00.157.15.458.458.0 00.232.054.454.454.0 00.232-.055.45.45.0 00.155-.149.664.664.0 00.087-.217 1.189 1.189.0 000-.519.642.642.0 00-.087-.214.446.446.0 00-.155-.146.459.459.0 00-.232-.054zm1.052.034-.423.31.158.216.24-.185v.945h.303V22.68zm-1.052.223c.04.0.073.014.098.043a.3.3.0 01.057.105.643.643.0 01.027.135 1.31 1.31.0 010 .268.654.654.0 01-.027.137.307.307.0 01-.057.105.124.124.0 01-.098.042.125.125.0 01-.098-.042.293.293.0 01-.059-.105.618.618.0 01-.028-.137 1.364 1.364.0 010-.268.612.612.0 01.028-.135.287.287.0 01.06-.105.123.123.0 01.097-.043z"/></svg></a><a target=_blank class=social title=Telegram href=https://t.me/adrbqt><svg xmlns="http://www.w3.org/2000/svg" width="1.2em" height="1.2em" viewBox="0 0 24 24"><path fill="currentcolor" d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm4.64 6.8c-.15 1.58-.8 5.42-1.13 7.19-.14.75-.42 1-.68 1.03-.58.05-1.02-.38-1.58-.75-.88-.58-1.38-.94-2.23-1.5-.99-.65-.35-1.01.22-1.59.15-.15 2.71-2.48 2.76-2.69a.2.2.0 00-.05-.18c-.06-.05-.14-.03-.21-.02-.09.02-1.49.95-4.22 2.79-.4.27-.76.41-1.08.4-.36-.01-1.04-.2-1.55-.37-.63-.2-1.12-.31-1.08-.66.02-.18.27-.36.74-.55 2.92-1.27 4.86-2.11 5.83-2.51 2.78-1.16 3.35-1.36 3.73-1.36.08.0.27.02.39.12.1.08.13.19.14.27-.01.06.01.24.0.38z"/></svg></a><a target=_blank class=social title="RSS Feed" href=/posts/index.xml><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1.2em" viewBox="0 0 1280 1280"><g transform="translate(0.000000,1280.000000) scale(0.100000,-0.100000)" fill="currentcolor"><path d="M2295 11929c-284-12-642-45-707-65-17-5-18-63-18-1039 0-569 4-1036 8-1039 5-3 74 6 153 19 510 86 1168 95 1789 25 1348-153 2602-677 3670-1531 385-308 820-744 1126-1129 842-1060 1362-2313 1514-3650 70-621 61-1279-25-1789-13-79-22-148-19-153 3-4 471-8 1039-8h1035l5 23c51 225 85 942 67 1419-23 605-77 1044-198 1617-294 14e2-927 2734-1823 3846-1043 1295-2364 2259-3909 2854-1158 447-2451 656-3707 6e2z"/><path d="M2255 7845c-269-25-620-81-667-106-17-9-18-55-18-899 0-706 3-890 13-890 6 0 66 18 132 41 130 44 288 79 467 105 154 21 577 30 749 15 1207-107 2267-823 2814-1902 166-327 268-637 330-1001 38-227 48-384 42-662-8-348-44-590-126-831-23-66-41-126-41-132 0-10 184-13 890-13 844 0 890 1 899 18 27 50 88 452 110 725 14 162 14 624 1 782-59 703-233 1323-545 1945-481 956-1313 1788-2270 2268-620 310-1239 483-1940 542-165 14-669 10-840-5z"/><path d="M2519 3815c-391-66-725-336-868-703-79-201-96-462-45-677 83-344 338-641 666-774 116-47 205-69 330-80 412-39 811 153 1040 5e2 193 292 240 648 128 981-135 403-492 699-914 757-1e2 14-241 12-337-4z"/></g></svg></a><a target=_blank class=social title=Email href=mailto:adrien.bouquet@bluewin.ch><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1.2em" viewBox="0 0 485.211 485.211"><path fill="currentcolor" d="M301.393 241.631 464.866 424.56H20.332l163.474-182.928 58.801 51.443 58.786-51.444zM462.174 60.651H23.027l219.579 192.142L462.174 60.651zM324.225 221.67l160.986 180.151V80.792L324.225 221.67zM0 80.792v321.029L160.972 221.64.0 80.792z"/></svg></a><p class=footnote>&copy; 2025 Adrien's Dashbook. All rights reserved.
Powered by <a target=_blank href=https://gohugo.io>Hugo</a> & <a target=_blank href=https://github.com/lukeorth/poison>poison</a></p></div></aside><main class="content container"><div class=post><div class=info><h1 class=post-title><a href=/writings/type-confusions/type-confusions/>Building a robust test suite of type confusion vulnerabilities</a></h1><div><h3 class=post-description>Master semester project @ HexHive Lab, EPFL</h3></div><div class=headline><div><time datetime=" 2024-06-07T00:00:00Z" class=post-date>June 7, 2024</time>
<span>-</span>
<span class=reading-time><span>22 mins read</span></span></div><ul class=tags><li class=tag-C/C++><a href=/%20tags/c/c++>C/C++</a></li><li class="tag-Type safety"><a href=/%20tags/type-safety>Type safety</a></li><li class=tag-Sanitizers><a href=/%20tags/sanitizers>Sanitizers</a></li></ul></div></div><p><em>This paper was written under the supervision of Nicolas Badoux and Prof. Doc. sc. ETH Mathias Payer from HexHive Lab at EPFL and is available in PDF format on <a href=https://github.com/abouquet27/typepp_report/blob/master/semester_project_report.pdf target=_blank>this repository</a></em>.</p><blockquote><p><em>&ldquo;Before I came here I was confused about this subject. Having listened to your lecture I am still confused. But on a higher level.&rdquo;</em>      - <strong>Enrico Fermi</strong></p></blockquote><h2 id=abstract>Abstract</h2><p>C++ has a lot of vulnerabilities due to type confusion, which can lead to memory corruption
and security vulnerabilities. Casting a pointer from a type to another is a highly
common operation but, if misused, can lead to type confusion and thus can be exploited.
Hextype<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> and Type++<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> are two mechanisms that aim to detect type confusion at runtime.
Although they achieve a high success rate, they can not ensure a perfect type safety.
We propose a benchmark that evaluates a range of type confusion cases by defining which
situations are likely to trigger type confusion. We evaluate it on Hextype and Type++ and
we conclude that they achieve a high success rate even if they do not pass all the tests.
In addition, we show that Type++ is more complete than Hextype as it detects more type confusion.</p><h2 id=introduction>Introduction</h2><p>According to <em>The Importance of Being Earnest</em> (TIOBE) index,
C++ is the 3rd most used programming language in the world<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>,
exceeding even Java. Both languages have in common object-oriented programming,
a paradigm that allows to organize code in objects that contain
both data and functions. In C++, objects are organized in hierarchies,
from base classes to derived classes and derived classes inherit
the characteristics of their base classes. However, this feature can lead to
type confusion vulnerabilities. A type confusion is a vulnerability that occurs
when a pointer is cast from a type to another type which is not compatible.
Hence, the compiler misinterprets the pointer. This mistyped pointer can be then
exploited by an adversary to execute arbitrary code, heap corruption and hijack the control-flow.
For instance, in 2021, a type confusion vulnerability was discovered in Telegram<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>
and could allow an adversary to access the heap memory.</p><p>To prevent these vulnerabilities, sanitizers such as Hextype<sup id=fnref1:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> and type++<sup id=fnref1:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> have been developed.
These tools aim to detect type confusions at runtime. Even if they achieve a high success rate,
they can not ensure a perfect type safety, and we want to measure their completeness.</p><p>In this paper, we propose a benchmark based on multiple perspectives of type confusion vulnerabilities.
We present the concept of initialization, modification and deletion of objects, and some special cases that are
worthwhile to evaluate due to their complexity. We evaluate this benchmark on Hextype and type++ and we conclude that
they achieve a high success rate even if they do not pass all the tests.</p><h2 id=background>Background</h2><p>C++ is a general purpose programming language widely-used in a lot of domains such as operating
systems, or machine learning. As C++ is a compiled language, it allows developers to write extremely
fast and efficient code that run with minimal overhead.
Types are a core concept in C++ but typecasting, which is the action of casting from a type to another,
is source of vulnerabilities. For instance, type confusion is a common security issue in C++, which
occurs when the compiler misinterprets a pointer type generally after a wrong typecasting.
This can lead to memory corruption and security vulnerabilities. An adversary can then exploit this
vulnerability to execute arbitrary code, heap corruption and hijack the control-flow. Such an attack
occurred in the past in V8 in Google Chrome, where it allowed a remote attacker to potentially exploit
heap corruption via a crafted HTML page (CVE-2023-3079) <sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>. Hence, it is crucial to detect wrong
typecasting which induce type confusion. These wrong casts can occur when casting a pointer
outside a type hierarchy (<code>char*</code>to<code>void*</code>then casting to another type, see line 40 in Listing 2.1) or
inside a type hierarchy with classes and object-oriented programming e.g., casting a pointer from a
base class to a derived class. This can lead to memory corruption and security vulnerabilities.
In this chapter, we will present the concept of the object-oriented programming, class hierarchies
and inheritance in C++ section 2.1, and present the different type casting operators in C++ section 2.2.
Finally, we will present the different mitigation mechanisms to type confusion and how they handle
it section 2.3.</p><h3 id=object-oriented-programming>Object-Oriented Programming</h3><p>Object-Oriented Programming (OOP) is o¸ncept focus on creating objects which are instances of
classes that contain both data and functions. This paradigm provides data abstraction, faster
execution and code reusability. Classes are organized in hierarchies, generally with one base class
and one derived, and can inherit attributes and methods from other classes which they then can
use or override. In Listing 2.1, classes<code>Password</code>and<code>Dummy</code>are derived from the base
class<code>Base</code>, whereas the class Unrelated is unrelated to their class hierarchy. A derived class can have multiple
base classes and thus possesses all the methods and attributes from its base classes. Furthermore, a
derived class is a subtype of its base class, meaning that a derived class can be used in place of its
base class e.g., at line 48 a<code>Password</code>pointer is given instead of a<code>Base</code>pointer. This concept which
is called polymorphism, is remarkably practical but leads to some issues. For instance, when a base
class has two derived classes that are not directly related to each other, it is possible to cast a pointer
from one derived class to another in type casting by the base class. This comes from C compatibility
as all casts are allowed in C and C++ developers tried to keep that. However, this behavior induces
type confusion, as at line 35, where a<code>Password*</code>is cast to a <code>Dummy*</code> after being cast to a<code>Base*</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Base</span> {}; <span style=color:#75715e>// Base class
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Dummy</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> Base { <span style=color:#75715e>// Derived class
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>       <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> printMessage(string message) {
</span></span><span style=display:flex><span>              cout <span style=color:#f92672>&lt;&lt;</span> message <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>       }
</span></span><span style=display:flex><span>       
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Password</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> Base { <span style=color:#75715e>// Derived class 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>       string password <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;empty&#34;</span>;
</span></span><span style=display:flex><span>       <span style=color:#75715e>// private function that cannot be accessed from outside the class
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>       <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>modifyPassword</span>(string newPassword) {
</span></span><span style=display:flex><span>              password <span style=color:#f92672>=</span> newPassword;
</span></span><span style=display:flex><span>       }
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>       Password(string newPassword) { modifyPassword(newPassword); }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>printPassword</span>() { cout <span style=color:#f92672>&lt;&lt;</span> password <span style=color:#f92672>&lt;&lt;</span> endl; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Unrelated</span> { <span style=color:#75715e>// Unrelated class
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>       <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span> 
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> doRandomStuffWithString(string str) {
</span></span><span style=display:flex><span>              <span style=color:#75715e>/* random stuff*/</span>
</span></span><span style=display:flex><span>              cout <span style=color:#f92672>&lt;&lt;</span> str <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>       }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Type confusion inside the hierarchy
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>typeConfusionInHierarchy</span>(Base<span style=color:#f92672>*</span> base) { 
</span></span><span style=display:flex><span>       Dummy<span style=color:#f92672>*</span> dummy <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>Dummy<span style=color:#f92672>*&gt;</span>(base); 
</span></span><span style=display:flex><span>       <span style=color:#75715e>// Illegal access
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>       dummy<span style=color:#f92672>-&gt;</span>printMessage(<span style=color:#e6db74>&#34;You have been hacked&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Type confusion outside the hierarchy
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>typeConfusionOutsideHierarchy</span>(Base<span style=color:#f92672>*</span> base) {
</span></span><span style=display:flex><span>       Unrelated<span style=color:#f92672>*</span> unrelated <span style=color:#f92672>=</span> <span style=color:#66d9ef>reinterpret_cast</span><span style=color:#f92672>&lt;</span>Unrelated<span style=color:#f92672>*&gt;</span>(base);
</span></span><span style=display:flex><span>       <span style=color:#75715e>// Illegal access
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>       unrelated<span style=color:#f92672>-&gt;</span>doRandomStuffWithString(<span style=color:#e6db74>&#34;You have been hacked twice&#34;</span>); 
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>       Password password(<span style=color:#e6db74>&#34;MyHardPassword&#34;</span>); <span style=color:#75715e>// Password initialization 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>       Base<span style=color:#f92672>*</span> base <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>password; <span style=color:#75715e>// upcast to base class
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>       password.printPassword(); <span style=color:#75715e>// print &#34;MyHardPassword&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>       typeConfusionInHierarchy(base); <span style=color:#75715e>// polymorphism 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>       password.printPassword(); <span style=color:#75715e>// print &#34;You have been hacked&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>       typeConfusionOutsideHierarchy(<span style=color:#f92672>&amp;</span>password);
</span></span><span style=display:flex><span>       password.printPassword(); <span style=color:#75715e>// print &#34;You have been hacked twice&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>       <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><em>Listing 2.1 - Example of type confusion in C++ within the same class hierarchy.</em></p><h3 id=type-casting>Type Casting</h3><p>Typecasting is the operation of casting a pointer from a type to another. C++ provides four casting
operators: <code>static_cast</code>, <code>dynamic_cast</code>, <code>const_cast</code> and <code>reinterpret_cast</code>.</p><p><code>const_cast&lt;target-type>(expression)</code>revokes the const or volatile attribute of an ob-
ject. Due to operator’s behavior, it does not impact type hierarchies and thus does not lead to type
confusion, although there are some issues with const_cast. It is out of scope of this paper and will
not be discussed further.</p><p><code>static_cast&lt;target-type>(expression)</code>casts an expression to a specified type while check-
ing at compile-time if target type and expression’s type are related but not at runtime. Therefore, this
reduces cast verification to checking the types in the type hierarchy. It does not guarantee the types
are compatible at runtime and places the onus back on programmers to ensure type correctness.
Hence, it leads to a type confusion vulnerability when misused i.e., casting from the base class to a
derived class or when casting a pointer to a void pointer.</p><p><code>reinterpret_cast&lt;target-type>(expression)</code>similarly to <code>static_cast</code>, it casts an expres-
sion to a specified type by reinterpreting the underlying bit pattern but with the difference that it
does not check anything neither at compile time nor at runtime. Hence, it can potentially cast two
incompatible types and lead to type confusion. It is also the programmer’s responsibility to ensure
the correctness of the target-type and the type of expression.</p><p><code>dynamic_cast&lt;target-type>(expression)</code>casts safely an expression to a specified type and
checks at compile-time and at runtime, unlike <code>static_cast</code>, if the types are compatible. To achieve
the runtime check, some forms of<code>dynamic_cast</code>rely on run-time type identification (RTTI), that is,
information about each polymorphic class in the compiled program. However, this metadata is only
available when the class has at least one virtual function and thus is polymorphic, which constraint
to use<code>dynamic_cast</code>only on polymorphic classes.</p><p>Finally, C-style typecasting exists in C++ due to backward compatibility between both languages
but highly discouraged due for instance to its lack of clarity for programmers. Furthermore, the com-
piler translate C-style typecasting to (i)<code>const_cast</code>, (ii)<code>static_cast</code>and (iii)<code>reinterpret_cast</code>
in this preferred order which passes on the underlying types confusions.</p><h3 id=type-confusions-and-mechanisms>Type confusions and Mechanisms</h3><p>As previously mentioned, type confusion vulnerabilities can lead to some memory corruption and
security vulnerabilities which products such as Telegram, (CVE-2021-31318<sup id=fnref1:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>, CVE-2021-31317<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>)
or Google Chromium (CVE-2022-2295<sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup>) are exposed to. Listing 2.1 shows an example of a type
confusion. First, we define a base class <code>Base</code> and two derived classes <code>Dummy</code> and <code>Password</code> with
their own attributes and methods. We set up the password to &ldquo;MyHardPassword&rdquo; (line 45) of our
class. A type confusion inside a type hierarchy can occur when there is a cast from a base to a
derived class. In our example, the password pointer is cast to its base and passed (line 48) to
<code>typeConfusionInHierarchy()</code> (line 36) which cast it to a <code>Dummy*</code>(line 35). From this line, the
behavior is undefined and can lead to memory corruption. Even if it’s calling <code>printMessage()</code> of
<code>Dummy</code>, it will execute <code>modifyPassword()</code> which will modify our password. This behavior is due
to object being a <code>Password</code> object, and it will call <code>modifyPassword()</code> method. A type confusion
outside a type hierarchy can occur when there is a cast from a base to an unrelated class. We
can observe this behavior in <code>typeConfusionOutsideHierarchy()</code> (line 41) where the password
pointer is cast to an <code>Unrelated*</code> (line 40). Calling <code>doRandomStuffWithString()</code> will call in fact
<code>modifyPassword()</code> and modify our password a second time. An adversary could exploit vulnerabilities,
especially if the program takes some inputs to the program from its user. However, some
downcast or unrelated cast be legitimate when the programmer is sure of the type of the object, and
we want to avoid false positive as well as false negative.</p><p>Hence, it is a problem that require to be handled for developer and user safety. The compiler
checks statically the correctness of each cast to ensure that the types are compatible, but it does not
guarantee the same correctness at runtime, because for instance an object of a derived class can
be used in place of an object of a base class due to polymorphism and vice versa as in line 48. To
detect type confusion at runtime, there exists two approaches: (i) relying on disjoint metadata, such
as type table to keep track of each type of each object or trees for type hierarchy, and (ii) relying on
existing metadata Runtime Type Information (RTTI), such as vtables. Generally, the first approach is
more complete because it covers more types, but it introduces overhead and performance issues.
The second is faster but less complete due to its limitation to polymorphic classes, and it caused
some crash issue. In this paper, we will focus and compare on two methods: Hextype <sup id=fnref2:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> and
type++<sup id=fnref2:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>. Both checks types correctness at runtime, but they differ in their approach. Hextype is
older and relies on disjoint metadata to achieve types correctness. Type++ is a recent C++ dialect
and relies on existing metadata to achieve types correctness but unlike an approach based solely
on existing metadata for polymorphism object, it extends this by adding a vtable pointer to each
object to increase efficiency, cover more types and avoid crash issue. In the following, we will detail
how Hextype and type++ work. Comparing them offers a perspective on the effectiveness of each
approach, despite the age difference between the development of these two mechanisms.</p><h4 id=hextype>Hextype</h4><p>HexType is a Clang/LLVM-based type confusion sanitizer used to detect type confusion vulnerabili-
ties in C++ programs. It relies on disjoint metadata to keep track of each type of each object and to
check types correctness at runtime. When compiling a program, Hextype creates a type table which
contains all the relationship information. Then at runtime, it collects the types of each allocated
object inside called object mapping table. Finally, when a cast happens, it verifies if the cast is
correct by comparing the two previously defined tables and thus detect type confusion. However,
Hextype has some limitations, as it considers only type confusion between derived classes and not
between unrelated classes.</p><h4 id=type>type++</h4><p>Type++ is a recent C++ dialect that extends the C++ language to prevent type confusions. It relies
on existing metadata, more precisely vtable pointer, to achieve types correctness, but instead ofhugp
keeping only polymorphic objects, it extends this property to all objects. At compile, it adds that
vtable pointer to each object to keep track of the type of the object and then at runtime, it checks if
the cast is correct by comparing the vtable pointer of the object.</p><h2 id=design>Design</h2><p>Type confusion sanitizers are designed to detect type confusion vulnerabilities in C++ programs.
Our threat model assumes that an adversary can exploit type confusion vulnerabilities to execute
arbitrary code. We built a test suite with a multitude of cases to evaluate how a sanitizer or a
C++ dialect can detect these types confusion and, a fortiori, try to prevent such adversaries from
exploiting these vulnerabilities, In this chapter, we will present the design of the test suite for
type confusion vulnerabilities, which decisions or language specifications we want to evaluate the
sanitizer on.</p><h3 id=benchmarking-type-confusion>Benchmarking Type Confusion</h3><h4 id=initialization>Initialization</h4><p>Initialization is a highly important step in a program. When creating an object, its type is assigned.
At this point, both methods act on values to keep track of their types, type++ by adding a vtable
pointer to every object and Hextype by recording all necessary information in its disjoint metadata.
We will evaluate their completeness i.e., their capacity to keep track and detect type confusion over
a maximum of initialization methods. In the following, we will present various specific forms of
object initialization on which we will evaluate the sanitizers.</p><h4 id=direct-initialization>Direct initialization</h4><p>Direct initialization is the simplest way to initialize an object and thus essential to measure if
sanitizers efficiency. It consists of a creating an object from a set of arguments. In fact in Listing 2.1,
password is directly initialized with the string &ldquo;MyHardPassword&rdquo; at line 45.</p><h4 id=copy-initialization>Copy initialization</h4><p>Copy initialization is another way to initialize an object. It consists of creating an object from another
object. With Copy initialization, we want to ensure that a sanitizer keep track of the type of object
when it is copied. For instance, if we copy an object of a derived class, we expect methods to keep
track of the type of this object and not lose any information, especially when casting to another type.</p><h4 id=list-initialization>List initialization</h4><p>List initialization, directly or copy initialized, is a way to initialize an object from a list of arguments.
It is a more recent way as it appears with C++11 to initialize an object and is particularly worthwhile
to evaluate the completeness of the sanitizer.</p><h4 id=c-style-allocators-and-new-operator>C-style Allocators and new operator</h4><p>C-style allocators such as <code>malloc</code>, <code>calloc</code> and <code>realloc</code> are used to allocate memory. They are a
heritage from C and are still used in C++. The new operator is a C++ operator that allocates memory
and initializes the object. These operators allocate memory dynamically i.e., at runtime and without
a fixed size. Unlike other methods which a return an object of a known type, they return a void
pointer that can be cast to any type. Depending on the size of the memory allocated, it can contain
multiple objects. Thus, it is interesting to observe how the sanitizer behaves when the memory is
allocated with these functions and if they manage to keep track correctly of the type of the objects.</p><h3 id=modification--deletion>Modification & Deletion</h3><p>Many edge cases happen when modifying the pointers by casting, modifying the object referenced
to the pointer, or deleting a pointer and reusing it to observe or in order to study the limitations of
sanitizers. For instance, <code>placement new</code> is a variation of <code>new</code> operator and allows the programmer
to construct an object at already allocated memory. Within a same memory block, we can construct
multiple objects of different types, which can lead to type confusion if these objects are not correctly
initialized. Furthermore, we try to modify the pointers by casting, modifying the object referenced to,
or deleting a pointer and reusing it to observe if it correctly detects type confusion. These examples
are particularly known to be an issue for Hextype.</p><h3 id=special-cases>Special cases</h3><p>Along with the initialization and modification of objects, there are some more precise cases that are
interesting to evaluate because they are tricky to handle for a sanitizer. Next, we present some of
these cases that generates type confusion vulnerabilities:</p><h4 id=multiple-inheritance>Multiple Inheritance</h4><p>Multiple inheritance is a feature of C++ that allows a class to inherit attributes and methods from multiple classes.
It allows the creation of complex class hierarchies and does not restrict the pro-
grammer to a single inheritance per object. Furthermore, its application is truly advantageous when
objects have to share multiple characteristics of several type hierarchies.</p><h4 id=union>Union</h4><p>A union is a special class type that allows to store different types of data in the same memory location
The feature is particularly useful for saving memory as only the last object assigned to it is actually
stored, but can be risky to use and understand. When dealing with unions from the point of view of
type confusion, we must not confuse type confusion with undefined behavior. In fact, it is up to the
programmer to ensure that the type of the value retrieve from the union is the correct one. With
union type confusions happen when the value retrieved is correct but is wrongly cast to another
type. For instance in Listing 3.1, the pointer u.b references a Base object but is cast to a Derived
object at line 15. This is a real type confusion and should be detected by the sanitizer. However, at
line 16, the pointer u.u references the same object as u.b(due to union nature) but is cast to an
Unrelated object. Trying to access u.u will lead to undefined behavior but is not a type confusion.
Nevertheless, there exist tagged unions, also known as variant, from C++17 onwards, which are a
safer union that uses a tag to keep track of the type of the object stored in the union. It will not be
evaluated in this paper but could be interesting to evaluate in the future.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Base</span> {};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Derived</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> Base {<span style=color:#66d9ef>float</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0</span>;};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Unrelated</span> { <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>void</span> doSomething() {}};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>union</span> <span style=color:#a6e22e>Union</span> {
</span></span><span style=display:flex><span>    Base <span style=color:#f92672>*</span>b;
</span></span><span style=display:flex><span>    Unrelated <span style=color:#f92672>*</span>u;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span> () {
</span></span><span style=display:flex><span>    Union u;
</span></span><span style=display:flex><span>    u.b <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Base(); 
</span></span><span style=display:flex><span>    Derived<span style=color:#f92672>*</span> d <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>Derived<span style=color:#f92672>*&gt;</span>(u.b); <span style=color:#75715e>// Type confusion
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    u.u<span style=color:#f92672>-&gt;</span>doSomething(); <span style=color:#75715e>// Undefined behavior 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><em>Listing 3.1: Union example</em></p><h4 id=phantom-casting>Phantom Casting</h4><p>Phantom casting occurs when a base class and a derived have the same data layout. In this case, it
is usually possible to cast a pointer from a base class to a derived class even if the object is not of
the derived class which should be classified as a type confusion. This special case exists because of
backward compatibility of C++ with C. Listing 3.2 shows an example of phantom casting at line 7.
The pointer base references a Base object but is cast to a <code>Derived object</code>, but this is allowed.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Base</span> {};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Derived</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> Base {};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>       Base<span style=color:#f92672>*</span> base <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Base();
</span></span><span style=display:flex><span>       Derived<span style=color:#f92672>*</span> derived <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>Derived<span style=color:#f92672>*&gt;</span>(base); <span style=color:#75715e>// Phantom casting |\label{code:phantom_casting}|
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>       <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><p><em>Listing 3.2: Phantom casting example</em></p><h2 id=implementation>Implementation</h2><p>We want to compare the results obtained from Hextype and type++ between them. The benchmark
quality resides in the diversity and coverage offered by the tests. In the following we will concentrate
on C++11, although there are more recent versions with more features dedicated to OOP. In addition,
we mainly test the standard C++11 without any external libraries or frameworks to simplify and
evaluate the basis of the language itself. Next, we would describe some challenge we faced during
the implementation of the test suite.</p><h4 id=set-up-sanitizers>Set up sanitizers</h4><p>Setting up sanitizers was the first step in the implementation of the test suite. The test suite is
designed to be run with Hextype and type++ to evaluate their completeness on type confusion
vulnerabilities. It is located inside type++ architecture and did not need to be installed. However,
Hextype had to be installed and configured to be able to run the test suite. Hextype can only run up
to C++14 and is not compatible with C++17 or C++20, which is a limitation for the test suite. Hextype
only triggers derived type confusion whereas type++ triggers derived and unrelated type confusion
inside and outside. Furthermore, Hextype should update its type table to reflect the new type of the
object, when a pointer is modified or used after being deleted, but sometimes it fails to do so and
produces false negatives or false positives.</p><h4 id=correctly-trigger-type-confusion>Correctly trigger type confusion</h4><p>One challenge was to correctly create our test cases such that we create legitimate type confusion.
Unions, phantom casting and multiple inheritance were difficult to implement so that they generate
legitimate type confusion and not undefined behavior or valid cast. For instance, making simple
test cases by having very simple base class and a derived class could trigger phantom casting and
hence no type confusion were spotted. On another hand, we spent a lot of time doing test cases
on unions before realizing how to properly create confused types and not undefined behaviors. In
order to reproduce the test suite, it is important to have a class structure that is not too complex
but not too simple either, such that it does not trigger phantom casting or multiple inheritance and
treating those cases separately.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span>{};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> A{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> b <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>C</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> B{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> c <span style=color:#f92672>=</span> <span style=color:#ae81ff>4.5</span>;
</span></span><span style=display:flex><span>}; 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>    A<span style=color:#f92672>*</span> a <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> A();
</span></span><span style=display:flex><span>    A<span style=color:#f92672>*</span> abis <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> B();
</span></span><span style=display:flex><span>    A<span style=color:#f92672>*</span> ac <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> C();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    B<span style=color:#f92672>*</span> b <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>B<span style=color:#f92672>*&gt;</span>(a); <span style=color:#75715e>// This is not allowed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    B<span style=color:#f92672>*</span> b2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>B<span style=color:#f92672>*&gt;</span>(abis); <span style=color:#75715e>// This is allowed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    B<span style=color:#f92672>*</span> b3 <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>B<span style=color:#f92672>*&gt;</span>(ac); <span style=color:#75715e>// This is allowed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    C<span style=color:#f92672>*</span> c <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>C<span style=color:#f92672>*&gt;</span>(a); <span style=color:#75715e>// This is not allowed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    C<span style=color:#f92672>*</span> c2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>C<span style=color:#f92672>*&gt;</span>(abis); <span style=color:#75715e>// This is not allowed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    C<span style=color:#f92672>*</span> c3 <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>C<span style=color:#f92672>*&gt;</span>(ac); <span style=color:#75715e>// This is allowed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    C<span style=color:#f92672>*</span> c4 <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>C<span style=color:#f92672>*&gt;</span>(b2); <span style=color:#75715e>// This is not allowed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    C<span style=color:#f92672>*</span> c5 <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>C<span style=color:#f92672>*&gt;</span>(b3); <span style=color:#75715e>// This is allowed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p><em>Listing 4.1: Example of test cases (taken from derived_simple_cast.cpp)</em></p><h2 id=evaluation>Evaluation</h2><p>We first evaluate each mechanism separately. Subsequently, we will compare them, discuss the
results and the limitations of the test suite.</p><h4 id=type-1>Type++</h4><p>Over the 38 test cases we created, type++ passes 35 and fails 3 of them. 2 of the failed due to multiple˙
inheritance, which make 92.1% of success rate. The main issue is that type++ does not handle multiple
inheritance. The test multiple_parent, a simple test case with a class that inherits from two
classes. When we create an object of the second base class and cast it to the derived class, it should
be detected as a type confusion. However, type++ does not detect it and classifies it as &ldquo;missed&rdquo;. The
last test case that failed is union_casting, where we try to cast a pointer on a union to a pointer of
a value inside the union. This test case is not detected as a type confusion by type++.</p><h4 id=hextype-1>Hextype</h4><p>Over the 38 test cases we created, Hextype passes 31 and fails 7 of them which makes 81.6% of success
rate. The main reason that justifies these failures is that Hextype does not handle very well C-style
allocators. 4 test fail because of them. As we mentioned previously, these allocators are known to be
a challenge for Hextype and its misses when we initialize object inside allocated memory. Regarding
the last 3 failed test cases, 2 are caused by vectors and the last one is due to unions.</p><p>#### Discussion</p><p>When comparing the two mechanisms numerically, we can see that type++ is more complete than
Hextype. Indeed, type++ detects more derived type confusion than Hextype. Another advantage of
type++ is that it detects unrelated type confusion, which Hextype does not. Any idea to increase the
completeness of Hextype would be to enforce the type table on all objects and not only on allocated
object. The objective of the test suite is to evaluate the mechanisms on a range of cases, and to trigger
some edge cases that are known to be difficult to handle for sanitizers. However, it is important
to highlight that our test suite has been made manually and is not exhaustive. Furthermore, the
benchmark is restricted to standard C++11 does not take into account from newer versions. It does
not include external libraries or frameworks to simplify the evaluation of the mechanisms, but they
could be interesting to evaluate in the future. Finally, we could also test other sanitizers to compare
them with Hextype and type++ and evaluate the completeness of our test suite.</p><h2 id=related-work>Related Work</h2><p>Type confusions continue to be studied and Hextype and type++ are not the only mechanisms
that aim to detect them. TypeSan <sup id=fnref:8><a href=#fn:8 class=footnote-ref role=doc-noteref>8</a></sup> is a type confusion detector also based on LLVM framework.
Similarly to Hextype, TypeSan relies on disjoint metadata to keep track of each type of each object
and to check types correctness at runtime. However, TypeSan uses shadow memory scheme.
More recently, we can mention TCD <sup id=fnref:9><a href=#fn:9 class=footnote-ref role=doc-noteref>9</a></sup> a static type confusion detector. Unlike the 3 mentioned
above, it works by static analysis and is proven to handle complex feature as multiple inheritance or
placement new.</p><h2 id=conclusion>Conclusion</h2><p>In the conclusion you repeat the main result and finalize the discussion of your project. Mention
the core results and why as well as how your system advances the status quo.</p><p>In conclusion, we have built a test suite based on C++ features and edge cases generating type
confusion vulnerabilities. We have evaluated the completeness of Hextype and type++ on type
confusion vulnerabilities using our benchmark. We have shown that type++ is more complete than Hextype as it detects more type confusion.
Type++ achieve a 92.1% success rate whereas Hextype achieves an 81.6% success rate. We pointed out that Hextype does not handle well C-style allocators,
that type++ does not handle multiple inheritance, and they will serve as a basis for future work.</p><h2 id=acknowledgments>Acknowledgments</h2><p>I would like to thank my supervisor, Nicolas Badoux, for his guidance and support throughout this
project. Finally, I would like to thank my family and friends for their support</p><h2 id=bibliography>Bibliography</h2><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://nebelwelt.net/files/17CCS.pdf target=_blank>HexType: Efficient Detection of Type Confusion Errors for C++. 2024.</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref2:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://hexhive.epfl.ch/publications/files/25NDSS.pdf target=_blank>type++: Prohibiting Type Confusion with Inline Type Information.</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref2:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p><a href=https://www.tiobe.com/tiobe-index/ target=_blank>TIOBE index of june 2024. (visited on 06/07/2024)</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p><a href=https://nvd.nist.gov/vuln/detail/CVE-2021-31318 target=_blank>National Institute of Standards and Technology. NIST CVE-2021-31318 Detail Page. 2021.</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p><a href=https://nvd.nist.gov/vuln/detail/CVE-2023-3079 target=_blank>National Institute of Standards and Technology. NIST CVE-2023-3079 Detail Page. 2023.</a>&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p><a href=https://nvd.nist.gov/vuln/detail/CVE-2021-31317 target=_blank>National Institute of Standards and Technology. NIST CVE-2021-31317 Detail Page. 2021.</a>&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7><p><a href=https://nvd.nist.gov/vuln/detail/CVE-2022-2295 target=_blank>National Institute of Standards and Technology. NIST CVE-2022-2295 Detail Page. 2021.</a>&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:8><p><a href=https://dl.acm.org/doi/abs/10.1145/2976749.2978405 target=_blank>TypeSan: Practical Type Confusion Detection. 2016.</a>&#160;<a href=#fnref:8 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:9><p><a href=https://ieeexplore.ieee.org/abstract/document/8987463/figures#figures target=_blank>TCD: Statically Detecting Type Confusion Errors in C++ Programs. 2019.</a>&#160;<a href=#fnref:9 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div><hr><div class=footer></div></div></main><div class=article-toc><div class=toc-wrapper><h4 id=contents></h4><nav id=TableOfContents><ul><li><a href=#abstract>Abstract</a></li><li><a href=#introduction>Introduction</a></li><li><a href=#background>Background</a><ul><li><a href=#object-oriented-programming>Object-Oriented Programming</a></li><li><a href=#type-casting>Type Casting</a></li><li><a href=#type-confusions-and-mechanisms>Type confusions and Mechanisms</a></li></ul></li><li><a href=#design>Design</a><ul><li><a href=#benchmarking-type-confusion>Benchmarking Type Confusion</a></li><li><a href=#modification--deletion>Modification & Deletion</a></li><li><a href=#special-cases>Special cases</a></li></ul></li><li><a href=#implementation>Implementation</a><ul><li></li></ul></li><li><a href=#evaluation>Evaluation</a><ul><li></li></ul></li><li><a href=#related-work>Related Work</a></li><li><a href=#conclusion>Conclusion</a></li><li><a href=#acknowledgments>Acknowledgments</a></li><li><a href=#bibliography>Bibliography</a></li></ul></nav></div></div></div></body></html>